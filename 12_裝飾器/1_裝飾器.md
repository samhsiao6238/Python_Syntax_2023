# 裝飾器（Decorators）

## 基本介紹

- Python 的裝飾器用 `@` 符號表示。
- 裝飾器是一個進階功能，可用來修改或增強函數或類別的行為。
- 裝飾器是一種語法糖，本身也是一個函數，透過裝飾器來接受傳入這個函數，並返回一個新的函數。

### *範例 1*
```python
# 定義一個裝飾器
def my_decorator(func):
    # 裝飾器內建的功能
    def wrapper():
        print("發生在函式被呼叫之前的事情")
        # 呼叫原本的函式
        func()
        print("發生在函式被呼叫之後的事情")
    return wrapper

# 語法糖
@my_decorator
def say_hello():
    print("Hello!")

# 呼叫函式
say_hello()

```

    *計算結果*
```
    發生在函式被呼叫之前的事情
    Hello!
    發生在函式被呼叫之後的事情
```

## 使用情境

#### 輸出日誌

- 以下範例中，`my_decorator` 是一個裝飾器，它將一個函數 `func` 作為輸入，並返回一個新的函數 `wrapper`，這個新的函數會在調用 func 之前和之後打印一些訊息。
- 然後用 `@my_decorator` 來修飾 `say_hello` 函數，這樣每次調用 `say_hello` 函數時，都會先打印出 `Something is happening before the function is called.`，然後打印出 `Hello!`，最後再打印出 `Something is happening after the function is called.`。
- 裝飾器是一種強大的工具，可以用於各種各樣的應用，如 `記錄日誌`、`測試`、`檢查參數`、`執行代碼的計時` 等等。
- 請注意，過度使用裝飾器可能會使代碼變得難以理解和維護。
- 以下範例中，`log` 裝飾器記錄了函數名稱以及它的參數，當調用 `add(2, 3)` 時將輸出一條日誌信息。

##### *範例 2*
```python
# 導入logging模組
import logging

# 設定logging的基本設定
def log(func):
    def wrapper(*args, **kwargs):
        logging.debug(f'Running {func.__name__} with arguments {args} and kwargs {kwargs}')
        return func(*args, **kwargs)
    return wrapper

# 語法糖
@log
def add(x, y):
    return x + y

# 呼叫函式，設定logging的等級，只會印出DEBUG等級的訊息
logging.basicConfig(level=logging.DEBUG)

# 印出結果
print(add(2, 3))
```

    *計算結果*
```
    DEBUG:root:Running add with arguments (2, 3) and kwargs {}
    5
```

### 檢查參數類型

- 可以創建一個裝飾器來檢查函數參數的類型

- 以下範例會在調用 `add('hello', 3)` 時引發 `ValueError` 錯誤，原因是使用了 `@check_types((int, int))` 裝飾器要求 `add` 函數的兩個參數必須都是 int 類型。
- 當傳入一個字符串 `'hello'` 和一個 `整數 3` 給 `add` 函數時，裝飾器的 `check_types` 函數會檢查每個參數的類型。
- 因為 `'hello'` 不是 `int` 類型，所以會觸發 `ValueError` 錯誤。
- 藉由這個範例可以理解裝飾器可以在函數被調用之前或之後插入自定義的邏輯，如檢查參數的類型，而不需要修改函數本身的程式碼。
---

##### *範例 3*
```python
def check_types(types):
    def decorator(func):
        def wrapper(*args):
            for arg, t in zip(args, types):
                if not isinstance(arg, t):
                    raise ValueError(f'Argument {arg} is not of {t}')
            return func(*args)
        return wrapper
    return decorator

@check_types((int, int))
def add(x, y):
    return x + y

print(add(2, 3))  # this is fine
print(add('hello', 3))  # this will raise an error

```

    *計算結果*
```
    5



    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    Cell In[7], line 16
         13     return x + y
         15 print(add(2, 3))  # this is fine
    ---> 16 print(add('hello', 3))  # this will raise an error


    Cell In[7], line 6, in check_types.<locals>.decorator.<locals>.wrapper(*args)
          4 for arg, t in zip(args, types):
          5     if not isinstance(arg, t):
    ----> 6         raise ValueError(f'Argument {arg} is not of {t}')
          7 return func(*args)


    ValueError: Argument hello is not of <class 'int'>
```
---

### 計時

- 創建一個裝飾器來測量函數執行的時間。
---

##### *範例 4*
```python
import time

def timer(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f'Function {func.__name__} took {end_time - start_time} seconds to run.')
        return result
    return wrapper

@timer
def sleep(n):
    time.sleep(n)

sleep(2)

```
    
    *計算結果*
```
    Function sleep took 2.015591859817505 seconds to run.
```

---

END
