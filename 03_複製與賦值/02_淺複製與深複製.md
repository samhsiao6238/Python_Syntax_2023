# 淺複製、深複製

_特別要釐清 `物件` 與 `子物件` 是獨立的，所以探討淺複製與深複製時，務必明白正在敘述的是物件本身或是物件內的成員物件，也就是子物件_

<br>

## 淺複製

_淺複製時會建立一個 `全新的物件` ，但對於該物件中的子物件，淺複製只複製了參考而非子物件本身，所以無論子物件的可變性為何，新物件全部的子物件皆參考了原物件的子物件。基於以上特性，淺複製後對於可變類型子物件的修改，將使新舊物件同步變動，而不可變類型子物件則不受影響_

<br>

1. 淺複製的方式

   - 調用 Python 內建模組 copy.copy()。
   - 列表 `list` 除可調用 copy.copy() 進行淺複製，還可透過類別自帶的方法 `copy()` 進行物件淺複製。
   - 對 `序列類型物件`（如 list、tuple、str）進行 `切片` 也會進行淺複製。
   - 透過 `列表生成式` 亦可進行淺複製。

<br>

2. 淺複製的說明

   - 無論物件的本身是可變或是不可變類型，淺複製都會完整複製一個全新物件，複製後的內容相同但 `物件本身的 id 一定不同` 。
   - 無論子物件是可變或不可變，淺複製將會完全複製並保有對原物件所有元素的參考。
   - 若物件的 `子物件` 是 `不可變類型` 物件，在淺複製後試圖修改新物件的子物件，因為子物件的不可變特性將會建立新的子物件，因為新物件必定擁有新的參考，所以此修改不影響原物件的子物件。
   - 與前例相反的，若試圖修改淺複製物件中的可變類型子物件，因其可變性使其修改不會建立新物件，所以新舊物件的子物件將會同步改變。

<br>

### 範例

1. 調用列表的 `.copy()` 進行淺複製

   ```python
   # 建立一個列表，子物件包含可變類型與不可變類型
   numbers_1 = [1, 2, 3, [4, 5, 6], (7, 8, 9)]
   # 淺複製
   numbers_2 = numbers_1.copy()
   # 查看 numbers_1 和 numbers_2 的 id 及內容
   print('(1) numbers_1 和 numbers_2 的 id 及內容：')
   print(id(numbers_1), numbers_1)
   print(id(numbers_2), numbers_2)
   # 容器內的不可變物件的 id 與內容
   print('\n(2) 容器內的不可變物件的 id 與內容：')
   print(id(numbers_1[0]), numbers_1[0])
   print(id(numbers_2[0]), numbers_2[0])
   # 容器內的可變物件的 id 與內容
   print('\n(3) 容器內的可變物件的 id 與內容：')
   print(id(numbers_1[3]), numbers_1[3])
   print(id(numbers_2[3]), numbers_2[3])
   ```

   _結果：無論子物件的可變性，其 ID 都相同_

   ```bash
   (1) numbers_1 和 numbers_2 的 id 及內容：
   140644349177280 [1, 2, 3, [4, 5, 6], (7, 8, 9)]
   140644349177984 [1, 2, 3, [4, 5, 6], (7, 8, 9)]

   (2) 容器內的不可變物件的 id 與內容：
   140644341416176 1
   140644341416176 1

   (3) 容器內的可變物件的 id 與內容：
   140644349179392 [4, 5, 6]
   140644349179392 [4, 5, 6]
   ```

<br>

2. 透過遍歷觀察淺複製後的多層結構物件

   ```python
   # 建立一個列表，包含整數、列表、數組
   numbers_1 = [1, 2, 3, [4, 5, 6], (7, 8, 9)]
   # 淺複製
   numbers_2 = numbers_1.copy()

   print('【說明】無論容器內的元素是可變或不可變，淺複製將會完全複製並保有對原物件所有元素的引用。')
   print('(1) 逐一比較兩物件全部元素的 id 是否相同：')
   # 遍歷每一個元素
   for i in range(len(numbers_1)):
       # 檢查頂層元素的 id 是否相同
       print(id(numbers_1[i]) == id(numbers_2[i]), end=' ')

       # 如果元素是列表或數組，則檢查其內部元素的 id 是否相同
       if isinstance(numbers_1[i], (list, tuple)):
           # 加入分隔符號來分隔頂層元素與內部元素的比較結果
           print(':', end=' ')  
           for j in range(len(numbers_1[i])):
               print(id(numbers_1[i][j]) == id(numbers_2[i][j]), end=' ')
       # 換行以區隔不同的元素
       print('')  
   ```

   _結果_

   ```bash
   【說明】無論容器內的元素是可變或不可變，淺複製將會完全複製並保有對原物件所有元素的引用。
   (1) 逐一比較兩物件全部元素的 id 是否相同：
   True 
   True 
   True 
   True : True True True 
   True : True True True 
   ```

<br>

3. 淺複製後對 `不可變類型` 的子物件進行修改

   ```python
   # 建立一個列表，包含整數、列表、數組
   numbers_1 = [1, 2, 3, [4, 5, 6], (7, 8, 9)]
   # 淺複製
   numbers_2 = numbers_1.copy()
   # 複製後，輸出兩物件的 id 與內容
   print('(1) 複製後，輸出兩物件的 id 與內容：')
   print(id(numbers_1), numbers_1)
   print(id(numbers_2), numbers_2)
   # 後續要對第一個元素 numbers_1[0] 進行修改，因此輸出其 id 與內容進行觀察
   print('\n(2) 後續要對第一個元素 numbers_1[0] 進行修改，因此輸出其 id 與內容進行觀察：')
   print('【說明】id 相同，內容相同')
   print(id(numbers_1[0]), numbers_1[0])
   print(id(numbers_2[0]), numbers_2[0])

   # 修改第一個元素 numbers_1[0] 並觀察兩物件的 id 與 內容變化
   # 物件本身為可變物件，因此其 id 不變，
   numbers_1[0] = 999
   print('\n(3) 修改第一個元素 numbers_1[0] 並觀察兩物件的 id 與 內容變化：')
   print('【說明】id 與原本相同')
   print(id(numbers_1), numbers_1)
   print(id(numbers_2), numbers_2)
   # 觀察所修改的元素的 id 與內容
   print('\n(4) 觀察被修改的子物件的 id 與內容：')
   print('【說明】被修改的子物件 id 與值皆改變')
   print(id(numbers_1[0]), numbers_1[0])
   print(id(numbers_2[0]), numbers_2[0])
   ```

   _結果_

   ```bash
   (1) 複製後，輸出兩物件的 id 與內容：
   140644348814592 [1, 2, 3, [4, 5, 6], (7, 8, 9)]
   140643943639296 [1, 2, 3, [4, 5, 6], (7, 8, 9)]

   (2) 後續要對第一個元素 numbers_1[0] 進行修改，因此輸出其 id 與內容進行觀察：
   【說明】id 相同，內容相同
   140644341416176 1
   140644341416176 1

   (3) 修改第一個元素 numbers_1[0] 並觀察兩物件的 id 與 內容變化：
   【說明】id 與原本相同
   140644348814592 [999, 2, 3, [4, 5, 6], (7, 8, 9)]
   140643943639296 [1, 2, 3, [4, 5, 6], (7, 8, 9)]

   (4) 觀察被修改的子物件的 id 與內容：
   【說明】被修改的子物件 id 與值皆改變
   140643405067376 999
   140644341416176 1
   ```

<br>

4. 淺複製後對 `可變類型` 的子物件進行修改

   ```python
   # 對列表進行淺複製，並修改其中可變物件的元素
   print('【說明】對列表進行淺複製，並修改其中可變物件的元素')
   # 建立一個列表，包含整數、列表、數組
   numbers_1 = [1, 2, 3, [4, 5, 6], (7, 8, 9)]
   # 淺複製
   numbers_2 = numbers_1.copy()

   # 複製後，輸出兩物件的 id 與內容
   print('\n(1) 複製後，輸出兩物件的 id 與內容：')
   print(id(numbers_1), numbers_1)
   print(id(numbers_2), numbers_2)

   # 修改第四個元素 numbers_1[3] 並觀察兩物件的 id 與 內容變化
   print('\n(2) 修改第四個元素 numbers_1[3] 並觀察兩物件的 id 與 內容變化：')
   print('【說明】淺複製會複製全部的引用，當修改可變元素時，兩物件的值都會改變')
   numbers_1[3][0] = 999
   print(id(numbers_1), numbers_1)
   print(id(numbers_2), numbers_2)
   ```

   _結果_

   ```bash
   【說明】對列表進行淺複製，並修改其中可變物件的元素

   (1) 複製後，輸出兩物件的 id 與內容：
   140643943936704 [1, 2, 3, [4, 5, 6], (7, 8, 9)]
   140643281009664 [1, 2, 3, [4, 5, 6], (7, 8, 9)]

   (2) 修改第四個元素 numbers_1[3] 並觀察兩物件的 id 與 內容變化：
   【說明】淺複製會複製全部的引用，當修改可變元素時，兩物件的值都會改變
   140643943936704 [1, 2, 3, [999, 5, 6], (7, 8, 9)]
   140643281009664 [1, 2, 3, [999, 5, 6], (7, 8, 9)]
   ```

   ```python
   # 改用 copy.copy() 進行淺複製
   print('【說明】改用 copy.copy() 進行淺複製：')
   # 導入 copy 模組
   import copy
   # 建立一個列表，包含整數、列表、數組
   numbers_1 = [1, 2, 3, [4, 5, 6], (7, 8, 9)]
   # 淺複製
   numbers_2 = copy.copy(numbers_1)

   # 複製後，輸出兩物件的 id 與內容
   print('\n(1) 複製後，輸出兩物件的 id 與內容：')
   print('【說明】id 不同，但內容相同')
   print(id(numbers_1), numbers_1)
   print(id(numbers_2), numbers_2)

   # 後續要對第一個元素 numbers_1[0] 進行修改，因此輸出其 id 與內容進行觀察
   print('\n(2) 後續要對第一個元素 numbers_1[0] 進行修改，因此輸出其 id 與內容進行觀察：')
   print('【說明】id 相同，內容相同')
   print(id(numbers_1[0]), numbers_1[0])
   print(id(numbers_2[0]), numbers_2[0])

   # 修改第一個元素 numbers_1[0] 並觀察兩物件的 id 與 內容變化
   # 物件本身為可變物件，因此其 id 不變
   numbers_1[0] = 999
   print('\n(3) 修改第一個元素 numbers_1[0] 並觀察兩物件的 id 與 內容變化：')
   print('【說明】id 與原本相同')
   print(id(numbers_1), numbers_1)
   print(id(numbers_2), numbers_2)

   # 觀察所修改的元素的 id 與內容
   print('\n(4) 觀察所修改的元素的 id 與內容：')
   print('【說明】被修改的元素 id 與值皆改變')
   print(id(numbers_1[0]), numbers_1[0])
   print(id(numbers_2[0]), numbers_2[0])
   ```

   _結果_

   ```bash
   【說明】改用 copy.copy() 進行淺複製：

   (1) 複製後，輸出兩物件的 id 與內容：
   【說明】id 不同，但內容相同
   140643943938432 [1, 2, 3, [4, 5, 6], (7, 8, 9)]
   140643405746368 [1, 2, 3, [4, 5, 6], (7, 8, 9)]

   (2) 後續要對第一個元素 numbers_1[0] 進行修改，因此輸出其 id 與內容進行觀察：
   【說明】id 相同，內容相同
   140644341416176 1
   140644341416176 1

   (3) 修改第一個元素 numbers_1[0] 並觀察兩物件的 id 與 內容變化：
   【說明】id 與原本相同
   140643943938432 [999, 2, 3, [4, 5, 6], (7, 8, 9)]
   140643405746368 [1, 2, 3, [4, 5, 6], (7, 8, 9)]

   (4) 觀察所修改的元素的 id 與內容：
   【說明】被修改的元素 id 與值皆改變
   140643405054352 999
   140644341416176 1
   ```

<br>

## 深複製

_深複製時會建立一個 `全新的物件`，且會遞迴地複製該物件中的所有的子物件，然而子物件的複製會受到本身的可變屬性影響，當子物件為不可變類型時，新物件將引用其參考，至用可變類行的子物件，新物件將建立新的子物件。基於以上特性，深複製後對於子物件的修改，無論可變屬性為何，對原有物件皆不造成影響_

<br>

1. 深複製的方法

   - 調用 Python 內建模組 copy 中的 deepcopy() 方法深複製物件。

<br>

2. 深複製的說明

   - 進行深複製時會完整複製原物件內容。
   - 新舊物件及其所有元素都是完全獨立的，但特別注意，所謂的完全獨立並不代表複製完成時他們是完全沒有關連，其中在 id 的部分會依照資料類型不同而有不同處理規則。
   - 新物件中的不可變類型資料仍將參考原物件，這是因為不可變物件在下一次被修改時本就會建立新物件，所以在尚未變更時，基於效能與系統資源考量並無立即建立新物件的必要。
   - 新物件中的可變類型元素的會是全新物件並擁有不同參考(id)，但其高維度內的不可變類型資料仍將保有援物件的參考。

<br>

### 範例

1. 觀察深複製後兩物件的 ID

   ```python
   import copy
   # 建立一個列表，包含整數、列表、數組
   numbers_1 = [1, 2, 3, [[4, 4, 4], 5, 6], (7, 8, 9)]
   # 深複製
   numbers_2 = copy.deepcopy(numbers_1)

   # 複製後，輸出兩物件的 id 與內容
   print('\n(1) 深複製後，輸出兩物件的 id 與內容：')
   print('【說明】深複製會複製完整全新物件，所以物件的 id 不同，但內容相同')
   print(id(numbers_1), numbers_1)
   print(id(numbers_2), numbers_2)


   print('\n(2) 逐一比較兩物件全部元素的 id 是否相同：')
   print('【說明】無論物件內的元素是可變或不可變，都會被完整複製')
   print('【說明】其中可變元素將擁有新的 id，比較結果如下：')
   # 遍歷每一個元素
   for i in range(len(numbers_1)):
       # 檢查頂層元素的 id 是否相同
       print(id(numbers_1[i]) == id(numbers_2[i]), end=' ')

       # 如果元素是列表或數組，則檢查其內部元素的 id 是否相同
       if isinstance(numbers_1[i], (list, tuple)):
           # 加入分隔符號來分隔頂層元素與內部元素的比較結果
           print(':', end=' ')  
           for j in range(len(numbers_1[i])):
               print(id(numbers_1[i][j]) == id(numbers_2[i][j]), end=' ')
       # 換行以區隔不同的元素
       print('')  
   ```

   _結果_

   ```bash
   (1) 深複製後，輸出兩物件的 id 與內容：
   【說明】深複製會複製完整全新物件，所以物件的 id 不同，但內容相同
   140643943961920 [1, 2, 3, [[4, 4, 4], 5, 6], (7, 8, 9)]
   140643280766016 [1, 2, 3, [[4, 4, 4], 5, 6], (7, 8, 9)]

   (2) 逐一比較兩物件全部元素的 id 是否相同：
   【說明】無論物件內的元素是可變或不可變，都會被完整複製
   【說明】其中可變元素將擁有新的 id，比較結果如下：
   True 
   True 
   True 
   False : False True True 
   True : True True True 
   ```
2. ```python
   import copy
   # 建立一個列表，包含整數、列表、數組
   numbers_1 = [1, 200, 300, [[4, 4, 4], 5, 6], (7, 8, 9)]
   # 深複製
   numbers_2 = copy.deepcopy(numbers_1)

   # 輸出第四個元素 numbers_1[3] 的 id 與內容
   print('\n(1) 輸出第四個元素 numbers_1[3] 的 id 與內容：')
   print('【說明】這是可變元素，所以深複製後 id 不同，但內容相同')
   print(id(numbers_1[3]), numbers_1[3])
   print(id(numbers_2[3]), numbers_2[3])

   # 輸出第三個元素 numbers_1[2] 的 id 與內容
   print('\n(2) 輸出第三個元素 numbers_1[2] 的 id 與內容：')
   print('【說明】這是不可變元素，所以深複製後 id 相同，內容相同')
   print(id(numbers_1[2]), numbers_1[2])
   print(id(numbers_2[2]), numbers_2[2])

   # 對第四個元素 numbers_1[3] 進行修改，並觀察兩物件的 id 與 內容變化
   print('\n(3) 對第四個元素 numbers_1[3] 進行修改，並觀察兩物件的 id 與 內容變化：')
   print('【說明】深複製會複製完整全新物件，所以物件的 id 不同，但內容相同')
   numbers_1[3][0][0] = 999
   print(id(numbers_1), numbers_1)
   print(id(numbers_2), numbers_2)
   ```

   _結果_

   ```bash
   (1) 輸出第四個元素 numbers_1[3] 的 id 與內容：
   【說明】這是可變元素，所以深複製後 id 不同，但內容相同
   140644349179392 [[4, 4, 4], 5, 6]
   140643279231872 [[4, 4, 4], 5, 6]

   (2) 輸出第三個元素 numbers_1[2] 的 id 與內容：
   【說明】這是不可變元素，所以深複製後 id 相同，內容相同
   140644341416240 3
   140644341416240 3

   (3) 對第四個元素 numbers_1[3] 進行修改，並觀察兩物件的 id 與 內容變化：
   【說明】深複製會複製完整全新物件，所以物件的 id 不同，但內容相同
   140643943624832 [1, 2, 3, [[999, 4, 4], 5, 6], (7, 8, 9)]
   140644349176832 [1, 2, 3, [[4, 4, 4], 5, 6], (7, 8, 9)]
   ```

<br>

---

_END_
