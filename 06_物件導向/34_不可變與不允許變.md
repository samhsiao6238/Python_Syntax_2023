_進階說明 Python 的不可變特性_

# 不允許變 vs. 不可變性  

<br>

_附帶說明 Python 的魔法方法 `__slots__`_

## 說明
   
1. 在 Python 中，`__slots__` 的主要目的不僅是為了 `防止動態添加屬性`，還有為了優化記憶體，當使用 `__slots__` 時，Python 會為物件省略掉原本用來儲存物件屬性的 `__dict__` 屬性，這使得物件體積變得更小。

2. 雖然 `__slots__` 可以避免新的屬性被添加，但它不能阻止已定義的屬性值被修改，除非額外定義限制條件，具體上可搭配 `__setattr__` 達成屬性值不可修改。

3. `__new__` 是一個 `靜態 static` 方法，而不是一個 `實例 instance` 方法，因此它需要接受類作為第一個參數，而不是物件本身。
在一些情境下，`__slots__` 可能不適用，例如當我們想要使用弱引用時 (weakref 模組)，如果類定義了
`__slots__`，則必須提供一個名稱為 `__weakref__` 的 slot 來支援它。

4. 不可變性在許多情境下都很有用，例如當我們希望確保資料的完整性、線程安全或當我們希望使用物件作為字典的鍵時。

5. 當擁有 `__slots__` 的父類被繼承時，子類必須定義自己的 `__slots__`，因為它不會從父類中繼承。



<br>

## 不允許變 

_使用魔法方法 `__slots__`_

1. 魔法方法 `__slots__` 可以防止 `動態添加` 新的屬性，使得對象的屬性集合固定不變，一但定義了 `__slots__`，就是限制類的實例只可擁有  `__slots__` 數組中指定的屬性。

    ```python
    # 自定義一個不允許動態添加新的屬性的類
    class ImmutableClass:
        # 兩個屬性值
        __slots__ = ('x', 'y')
    ```

2. 不提供像 `.setter` 這樣的方法，或者使 `__setattr__` 拋出異常來防止修改屬性。

    ```python
    class ImmutableClass:
        __slots__ = ('_x', '_y')

        def __setattr__(self, *args):
            raise TypeError('不允許改變屬性')
    ```

3. 透過初始化屬性的時候提供所有必要的值

    ```python
    class ImmutableClass:
        __slots__ = ('_x', '_y')

        def __init__(self, x, y):
            object.__setattr__(self, '_x', x)
            object.__setattr__(self, '_y', y)
    ```

4. 僅提供 `__getter__` 方法來讀取屬性

    ```python
    class ImmutableClass:
        __slots__ = ('_x', '_y')

        def __init__(self, x, y):
            object.__setattr__(self, '_x', x)
            object.__setattr__(self, '_y', y)

        # 透過裝飾器
        @property
        def x(self):
            return self._x

        @property
        def y(self):
            return self._y
    ```

5. 若要添加屬性將會影發 `AttributeError`

    ```python
    class MyClass:
        __slots__ = ('x', 'y')

        def __init__(self, x, y):
            self.x = x
            self.y = y

    #
    obj = MyClass()
    obj.x = 1
    obj.y = 2
    # 以下代碼將引發 AttributeError
    # obj.z = 3
    ```


<br>

##  不可變

### 說明

1. 所謂的 `不可變類型`，是指物件一但建立之後，就無法在初始化時改變其值，而不是初始化之後不可再次改變其值。
2. 基於這樣的機制，對於一個不可變類型物件來說，僅可在 `__new__` 階段對其賦值，在初始化階段僅可添加其屬性，這樣的機制跟 `__slots` 有著本質上的差異， `__slots` 是不允許動態添加屬性的。

    ```python
    class ImmutableClass(object):
        #
        def __new__(cls, x, y):
            #
            instance = super(ImmutableClass, cls).__new__(cls)
            instance._x = x
            instance._y = y
            # __new__ 會傳回一個物件
            return instance

        # 透過裝飾器將方法轉換為屬性
        # 一但設置了 @property，若沒有搭配 setter 或 delete，屬性就成為唯讀的。
        @property
        def x(self):
            return self._x

        @property
        def y(self):
            return self._y

        @y.setter
        def y(self, value):
            self._y = value
    ```

<br>

## 精準的定義

### 定義

1. 使用 `__slots__` 確保不可以動態地添加新的屬性。
2. 在 `__new__` 方法中初始化所有屬性。
3. 確保 `__init__` 方法不進行任何修改。
4. 確保該類別中的所有方法都不修改任何屬性。
5. 無論是 `cls` 或是 `self` 都是約定成俗，而非嚴謹規定的命名，但為了提升代碼可讀性，通常用 `self` 代表實例，而 `cls` 代表的是類。
6. 再次強調， _`self` 代表的是類的實例，而非類的本身_。

<br>

### 說明
1. 在 Python 中，所有的類都隱式地繼承自 `object` 類，在沒有明確繼承父類時，其父類就是 `object`。
2. super() 是一個內置函數，它返回一個臨時對象，該對象的類型是當前類的父類。
3. 透過 super() 可以用來調用父類中被子類覆蓋（override）的方法。
4. super() 可以接受兩個參數，第一個參數是 `子類`，也就是當前調用父類的類，第二個參數是一個`對象`，通常是 cls （用於類方法）或 self（用於實例方法）。
5. 下方範例中的 `super(ImmutablePoint, cls).__new__(cls)`，就是調用當前類父類 `object` 的 `__new__` 方法，如此便可在不影響父類行為的前提下覆蓋 `override` 或拓展 `extend` 功能。


    ```python
    # 一個不可變物件的類，其屬性 x 和 y 一旦在初始化時設置後就不能再被修改。
    class ImmutablePoint:
        # 使用了 __slots__ 來限制允許的屬性。
        __slots__ = ('_x', '_y')
        # 在 __new__ 方法中進行所有屬性的初始化。
        def __new__(cls, x, y):
            # 調用父類（object）的方法
            # .__new__(cls)：這是調用父類（即 object 類）的 __new__ 方法。
            # cls：這只是當前類的參照，即 ImmutablePoint。
            obj = super(ImmutablePoint, cls).__new__(cls)
            obj._x = x
            obj._y = y
            return obj

        def __init__(self, x, y):
            # 什麼都不做
            pass
        
        # 使用了 @property 裝飾器提供讀取屬性的方法，
        # 但沒有提供設置方法，所以這些屬性是只讀的。
        @property
        def x(self):
            return self._x

        @property
        def y(self):
            return self._y

        def __repr__(self):
            return f"ImmutablePoint({self._x}, {self._y})"
    ```

<br>

---

_END_